"""
В реальной практике Вы не всегда контролируйте наполнение очереди. Наполнять очередь может внешний сервис, а Вам лишь остается работать на его условиях как есть. Никаких сигнальных элементов в очереди для удобства, никакого контроля за производителями с Вашей стороны. Все, что может быть известно о работе внешнего сервиса – это информация от отдела тестирования с результатом нагрузочных испытаний его производительности. Даже не обязательно внешний сервис. Вы можете работать в команде, где одна часть разработчиков работают над производителями. А Вам досталась разработка логики потребителей. В обоих случаях все проблемы взаимодействия Вы должны решить на своей "принимающей" стороне, в логике целевой задачи потребителей.

Давайте обыграем такой сценарий. Ваша конкретная задача:

двумя потоками -потребителями получать элементы из очереди tmp_queue и запускать функцию обработки handler для каждого полученного элемента. Функция обработки получает единственный аргумент – элемент из очереди;
потоки-потребители должны иметь имена (атрибуты .name) "consumer_1" и "consumer_2";
защитить потребителей от нарушений в работе производителей. Все что Вам известно – это данные о максимально допустимом времени добавления элемента в очередь: 100 мс.
Т.е. гарантируется, что в очередь каждые 0.1 секунды будет добавлен новый элемент;
Если работа на стороне производителей нарушается и Вы не можете получить элемент из очереди за установленное время, завершите работу потоков-потребителей, перед этим вызвав функцию логирования logging_escape, которая сообщает приложению о завершении работы потребителей и протоколирует причину завершения.
Тестирующая система создаст экземпляр очереди tmp_queue, запустит производителей для заполнения очереди. Затем запустит код Вашего решения и проверит время, порядок выполнения и вывод программы. Проверит логику завершения работы потоков-потребителей и вызов функции logging_escape.

Функции tmp_queue и logging_escape, определены в тестирующей системе. Не изменяйте их, только вызывайте.
"""

import threading
import queue


def consumer():
    while True:
        try:
            elem = tmp_queue.get(timeout=0.2)
            handler(elem)
            tmp_queue.task_done()
        except queue.Empty:
            logging_escape()
            break


threading.Thread(target=consumer, name="consumer_1").start()
threading.Thread(target=consumer, name="consumer_2").start()

tmp_queue.join()
