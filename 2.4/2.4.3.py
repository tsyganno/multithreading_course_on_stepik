"""
Воспроизведем функционал логирования отдельным потоком-таймером по простому условию: если рабочий поток не выполнил свою целевую задачу вовремя (не выполнил за контрольное время), то выполняется вспомогательный поток с целевой задачей логирования. Если выполнил — запуск потока логирования отменяется. Решение оформить в виде функции с именем test_thread_timer(t_check), где t_check — контрольное значение времени.

В тестирующей системе определена целевая функция рабочего потока executer, функция логирования logging.

В функции test_thread_timer Вам необходимо:

Создать и запустить рабочий поток с именем (атрибут name) Thread (англ).
Поставить на запуск с ожиданием t_check вспомогательный поток логирования с именем (атрибут name) Timer (англ.).
Ожидать завершения рабочего потока (ограничив ожидание контрольным значением времени).
Если время между запуском и завершением рабочего потока не превышает контрольного значения — отменить запуск потока логирования.
В решении нужно только определить функцию. Вызывать функцию будет тестирующая система с разными значениями времени контроля.

Внимание! Не надо ожидать завершения рабочего потока дольше контрольного времени. Вспомните об аргументе метода join и специальном аргументе потока.
"""

import threading
from time import perf_counter


def test_thread_timer(t_check: int | float) -> None:
    thread = threading.Thread(target=executer, name='Thread', daemon=True)
    timer = threading.Timer(t_check, logging)
    timer.name = 'Timer'
    thread.start()
    timer.start()
    start_time = perf_counter()
    thread.join(t_check)
    if not thread.is_alive():
        if (perf_counter() - start_time) > t_check:
            timer.cancel()
