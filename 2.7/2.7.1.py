"""
Вспоминаем прошлую задачу с концепцией один производитель – два потребителя. Условия задачи не изменились. Но теперь нужно повысить ее производительность, используя сигнальный элемент.

Задача производителя: наполнить очередь элементами из генератора get_obj().

Задача потребителей: получить элемент из очереди и запустить функцию обработки handler(). Функция обработки получает единственный аргумент – элемент из очереди.

Поток-производитель должен иметь имя (атрибут .name) "producer".
Потоки-потребители должны иметь имена (атрибуты .name) "consumer_1" и "consumer_2".

Ваше решение должно быть выполнено в следующем порядке:

Напишите функции производителя и потребителя. В функции производителя добавьте сигнальный элемент в конец очереди.
Создайте поток производителя. Запустите его выполнение. Не ждите завершения работы, сразу переходите к п.3.
Создайте потоки потребителей. Запустите их на выполнение. Дождитесь завершения их работы, чтобы все элементы из очереди были обработаны.
В качестве сигнального элемента можете использовать: число -1, None, False.
Внимание! не передавайте сигнальный элемент в функцию обработки handler, это приведет к ошибке.
Вы можете решить задачу используя один сигнальный элемент или два сигнальных элемента по числу потребителей, выбирайте любой подход.

Генератор get_obj, функция обработки handler заданы в тестирующей системе. Не изменяйте их, только вызывайте.

Тестирующая система проверит время Вашего решения, порядок выполнения и вывод программы. Проверит, что все элементы из генераторы были обработаны.
"""

import threading
import queue

my_queue = queue.Queue()


def producer():
    for elem in get_obj():
        my_queue.put(elem)
    my_queue.put(None)


def consumer():
    while True:
        elem = my_queue.get()
        if elem is None:
            my_queue.put(elem)
            return
        handler(elem)


thread_producer = threading.Thread(target=producer, name="producer")
thread_producer.start()

thread_consumer_1 = threading.Thread(target=consumer, name="consumer_1")
thread_consumer_2 = threading.Thread(target=consumer, name="consumer_2")
thread_consumer_1.start()
thread_consumer_2.start()
thread_consumer_1.join()
thread_consumer_2.join()
