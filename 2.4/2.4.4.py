"""
Напишите функцию callback_handler, которая запускает целевую задачу (например, выполнение запроса), а в случае получения результата за заданное время запускает дополнительную задачу (например, сохранение результата запроса).

Напишите функцию, которая выполняет целевую задачу task и задачу дополнительной обработки callback_task в отдельных потоках. При этом известно, что признаком успешного выполнения целевой задачи является переменная result, которая в случае успеха принимает значение True (False — значение по умолчанию). Булевская переменная result доступна в глобальной области видимости.

Целевая функция task принимает аргументы args в виде кортежа значений, поэтому при создании потока достаточно указать threading.Thread(target=task, args=args, ....). Функция callback_task  работает без аргументов и она выполняется не мгновенно, сохранение результатов занимает небольшое время! Обязательно и безусловно дождитесь ее выполнения в функции.

Для ограничения ожидания успешного выполнения целевой задачи ограничьте время работы потока целевой задачи 0.3 секундой (считаем, что за 300 мс. (или раньше) запрос точно будет успешно получен, если нет — дальнейшие ожидания нужно прекратить). Если result True, потоком-таймером выполняем дополнительную задачу и дожидаемся ее завершения, если нет — не выполняем (результат не получен, нечего сохранять).

Решите задачу без расчета времени выполнения, используйте поток, поток-таймер и методы join, start, cancel. Во временных уставках допускается погрешность в 0.05 секунды

Функции task, callback_task, переменная result определены в тестирующей системе. Не меняйте их, а только вызывайте. Система проверяет общее время решения и точность решения используя несколько запусков функции callback_handler.
"""

from threading import Timer, Thread
from typing import Callable


def callback_handler(task: Callable = None, args=(), callback_task: Callable = None) -> None:
    thread = Thread(target=task, args=args, daemon=True)
    timer = Timer(interval=0.305, function=callback_task)
    thread.start()
    timer.start()
    thread.join(0.3)
    if result:
        timer.join()
    else:
        timer.cancel()
