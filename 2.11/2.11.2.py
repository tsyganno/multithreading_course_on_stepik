"""
Напишите класс многопоточного обработчика заданий с ограничением по количеству одновременных выполнений по следующим условиям

Имя класса HubHandler.
Атрибуты создания:
n: int — значение ограничения одновременных выполнений,
task — целевая функция (не использует аргументов),
n_threads: int — количество потоков выполнения задания.
В классе кроме инициализатора должен быть публичный метод start_hub, вызываемый без аргументов. Он создает и запускает указанное количество потоков для выполнения целевой задачи с учетом ограничения по количеству одновременных выполнений.
При необходимости дополнительно можно создавать и использовать другие методы.
Решите задачу используя семафор.
В тестирующей системе будут созданы два экземпляры HubHandler с разными атрибутами для проверки необходимого поведения. Целевая функция также будет задана в тестирующей системе и представляет из себя две подзадачи (1 и 2). Тест. система проверит, что целевая функция выполняется полностью от начал до конца одним потоком, если n =1 и выполняется одновременно несколькими потоками в соответствии с указанным n.

Внимание! целевая функция не принимает и не использует никаких аргументов. Подумайте, как в классе можно защитить выполнение целевой функции семафором.
"""

import threading
from typing import Callable


class HubHandler:
    def __init__(self, n: int, task: Callable, n_threads: int):
        self.n = n  # Максимальное количество одновременно выполняемых задач
        self.task = task  # Функция, которую нужно выполнять
        self.n_threads = n_threads  # Количество потоков
        self.semaphore = threading.Semaphore(n)  # Ограничение по семафору
        self.threads = []  # Список потоков

    def _func(self):
        """Функция, выполняющая задачу с учётом семафора"""
        with self.semaphore:  # Автоматическое освобождение семафора после выхода из блока
            self.task()

    def start_hub(self):
        """Запускает потоки обработки заданий"""
        for _ in range(self.n_threads):
            thread = threading.Thread(target=self._func)
            self.threads.append(thread)
            thread.start()

        for thread in self.threads:
            thread.join()  # Ждём завершения всех потоков
